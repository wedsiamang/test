# 継承
#### abstract
- abstractメソッドは、サブクラスでオーバーライドさせるため付与する修飾子である
- abstractはクラス、メソッドに付与する修飾子であり、変数には付与できない
- abstractで修飾すると、実装を持つことができない（ {}中かっこを使わず、セミコロンのみで終わる）、中括弧をつけるとコンパイルエラー。
    

#### スーパークラスのメソッド呼び出し
- パッケージxyzのmainメソッドで呼び出したメソッドが、パケーじxyzの指定したBクラスにない場合、パッケージabcのスーパークラスAに定義がある場合は、パッケージが異なっていても呼び出しが可能である
- サブクラスのオブジェクトをスーパークラス型の変数に代入した場合、インスタンスメソッド以外はスーパークラスのメンバが呼び出される。
- インスタンス変数の呼び出しは、スーパークラスになる。

#### オーバーライド
スーパークラスに定義されたメソッドをサブクラスでオーバーライドする時のルール
- シグニチャが同じ
- 戻り値型が同じ型か、サブクラス型
- アクセス修飾子は同じか、より緩い
- throwsで宣言する例外は、スローする例外と同じ型かサブクラス型
- 継承：親のメソッドをそのまま使える、オーバーライドしていなくても呼べる（親のものを使うだけ）
- オーバーライド：同じシグネチャで再定義して振る舞いを変える、オーバーライドすると 子の実装が呼ばれる

#### コンストラクタチェイン
継承関係にある時、サブクラスよりも先にスーパークラスのコンストラクタが実行される。
```
class A {}
class B extends A{}
class C extends B{}
class Main{ public static main... {new C();}}
```
実行順はA→B→C

#### スーパークラス型のサブクラス参照宣言

A a = new B();
参照型（左辺の型）に定義されているメンバしか呼び出せない
- フィールド
  実行結果はスーパークラスのメソッド（参照型で決まる）
- static メソッド
  実行結果はスーパークラスのメソッド（参照型で決まる）
- インスタンスメソッド
  スーパークラスから見に行くが、動く実装はサブクラスのメソッド（参照先で決まる）

>[!TIP]
>サブクラスのオブジェクトをスーパークラス型の変数で参照していても、「呼び出せるメンバ」はスーパークラスに宣言されたものに限定される。
>ただし、インスタンスメソッドについては、実行時にサブクラスのオーバーライド実装が選ばれる。
