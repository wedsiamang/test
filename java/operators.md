# 演算子・インクリメント・デクリメント

#### インクリメント、デクリメント
##### 前置（演算子を変数の前に配置)
   |int a = 10;<br>int b = ++a;<br>①計算してから<br>②代入する|   
   |:---| 
##### 後置(演算子を変数の後に配置)
   |int a = 10;<br>int b = a++;<br>①代入してから<br>②計算する|
   |:---|

 |`aの初期値`|`式`|`実行後のaの値`|`実行後のbの値`|
|---|---|---|---|
|10|b=++a; |11|11|
|10|b=a++;|11|10|
|10|b=--a;|9|9|
|10|b=a--;|9|10|
#### 論理演算子 &と&&、|と||の違いに注意
|`演算子`|`記述例`|`説明`|
|:---|:---|:---|
|**&**|a&b|aとbの両方がtrueの時true、そうでなければfalse<br>aがfalseであったとしてもbは評価される|
|**&&**|a&&b|上記と異なるのは、aがfalseならbは評価されず結果がfalseとなる<br>aがtrueならbも評価され結果を返す|
|**\|**|a\|b|aとbいずれかがtrueならtrue,そうでなければfalse<br>aがtrueであったとしてもbは評価される|
|**\|\|**|a\|\|b|上記と異なるのは、aがtrueならbは評価されず結果がtrueとなる<br>aがfalseならbも評価され結果を返す|
|**^**|a^b|aとbの値が異なる時true,そうでなけれあばfalse|
|**!**|a!b|aの値がtrueの時false,falseの時true|

#### 型変換
小さいもの (byte)→大きいもの(double)への型変換は暗黙的に行われるが、逆は明示的なキャストが必要になる。

##### char → int がなぜ可能か
char は文字の糖衣構文であり、内実はUnicode（16ビットの整数（0〜65535）)であり、int より小さい型のため暗黙的型変換が可能。逆はキャストが必要。
```
'A' == 65      // true
'\u0041' == 'A' // true（16進表記）
```
#### ラッパークラス
基本データ型にはそれぞれに応じたラッパークラスが存在しており、自動変換すると、値を参照型として扱えるようになる。
ラッパークラスに基本データ型を代入するBoxing,基本データ型にラッパークラスを代入するUnBoxingがあるが、Boxingでは、暗黙的型変換は行われない。

#### if文の{}の省略
省略するとif文直下1行目のみ処理され、その下の行はif文としては処理されない
